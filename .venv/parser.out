Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> assignment_statement
Rule 5     statement -> print_statement
Rule 6     statement -> if_statement
Rule 7     statement -> function_definition
Rule 8     statement -> return_statement
Rule 9     statement -> expression_statement
Rule 10    statement -> lambda_expression
Rule 11    assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 12    print_statement -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 13    if_statement -> IF LPAREN expression RPAREN block elseif_list else_block
Rule 14    elseif_list -> elseif
Rule 15    elseif_list -> elseif_list elseif
Rule 16    elseif_list -> empty
Rule 17    elseif -> ELSEIF LPAREN expression RPAREN block
Rule 18    else_block -> ELSE block
Rule 19    else_block -> empty
Rule 20    block -> LBRACE statement_list RBRACE
Rule 21    function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block
Rule 22    parameter_list -> IDENTIFIER
Rule 23    parameter_list -> parameter_list COMMA IDENTIFIER
Rule 24    parameter_list -> empty
Rule 25    return_statement -> RETURN expression SEMICOLON
Rule 26    expression_statement -> expression SEMICOLON
Rule 27    expression -> NUMBER
Rule 28    expression -> IDENTIFIER
Rule 29    expression -> TRUE
Rule 30    expression -> FALSE
Rule 31    expression -> LPAREN expression RPAREN
Rule 32    expression -> expression PLUS expression
Rule 33    expression -> expression MINUS expression
Rule 34    expression -> expression TIMES expression
Rule 35    expression -> expression DIVIDE expression
Rule 36    expression -> expression MODULO expression
Rule 37    expression -> expression GT expression
Rule 38    expression -> expression LT expression
Rule 39    expression -> expression GE expression
Rule 40    expression -> expression LE expression
Rule 41    expression -> expression EQ expression
Rule 42    expression -> expression NEQ expression
Rule 43    expression -> expression AND expression
Rule 44    expression -> expression OR expression
Rule 45    expression -> NOT expression
Rule 46    expression -> MINUS expression
Rule 47    expression -> function_call
Rule 48    expression -> anonymous_function
Rule 49    expression -> lambda_call
Rule 50    expression -> empty
Rule 51    argument_list -> expression
Rule 52    argument_list -> argument_list COMMA expression
Rule 53    argument_list -> empty
Rule 54    lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON
Rule 55    anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
Rule 56    lambda_call -> IDENTIFIER LBRACE argument_list RBRACE
Rule 57    function_call -> IDENTIFIER LPAREN argument_list RPAREN
Rule 58    empty -> <empty>

Terminals, with rules where they appear

AND                  : 43
ASSIGN               : 11 54
COLON                : 54 55
COMMA                : 23 52
COMMENT              : 
DIVIDE               : 35
ELSE                 : 18
ELSEIF               : 17
EQ                   : 41
FALSE                : 30
GE                   : 39
GT                   : 37
IDENTIFIER           : 11 21 22 23 28 54 56 57
IF                   : 13
LAMBDA               : 54 55
LBRACE               : 20 54 55 56
LE                   : 40
LPAREN               : 12 13 17 21 31 54 55 57
LT                   : 38
MINUS                : 33 46
MODULO               : 36
NEQ                  : 42
NOT                  : 45
NUMBER               : 27
OR                   : 44
PLUS                 : 32
PRINT                : 12
RBRACE               : 20 54 55 56
RETURN               : 25
RPAREN               : 12 13 17 21 31 54 55 57
SEMICOLON            : 11 12 25 26 54
TIMES                : 34
TRUE                 : 29
ZAP                  : 21
error                : 

Nonterminals, with rules where they appear

anonymous_function   : 48
argument_list        : 52 56 57
assignment_statement : 4
block                : 13 17 18 21
else_block           : 13
elseif               : 14 15
elseif_list          : 13 15
empty                : 16 19 24 50 53
expression           : 11 12 13 17 25 26 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 46 51 52 54 55
expression_statement : 9
function_call        : 47
function_definition  : 7
if_statement         : 6
lambda_call          : 49
lambda_expression    : 10
parameter_list       : 21 23 54 55
print_statement      : 5
program              : 0
return_statement     : 8
statement            : 2 3
statement_list       : 1 3 20

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . assignment_statement
    (5) statement -> . print_statement
    (6) statement -> . if_statement
    (7) statement -> . function_definition
    (8) statement -> . return_statement
    (9) statement -> . expression_statement
    (10) statement -> . lambda_expression
    (11) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (12) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (13) if_statement -> . IF LPAREN expression RPAREN block elseif_list else_block
    (21) function_definition -> . ZAP IDENTIFIER LPAREN parameter_list RPAREN block
    (25) return_statement -> . RETURN expression SEMICOLON
    (26) expression_statement -> . expression SEMICOLON
    (54) lambda_expression -> . IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      shift and go to state 11
    PRINT           shift and go to state 13
    IF              shift and go to state 15
    ZAP             shift and go to state 16
    RETURN          shift and go to state 17
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    SEMICOLON       reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    assignment_statement           shift and go to state 4
    print_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    function_definition            shift and go to state 7
    return_statement               shift and go to state 8
    expression_statement           shift and go to state 9
    lambda_expression              shift and go to state 10
    expression                     shift and go to state 12
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . assignment_statement
    (5) statement -> . print_statement
    (6) statement -> . if_statement
    (7) statement -> . function_definition
    (8) statement -> . return_statement
    (9) statement -> . expression_statement
    (10) statement -> . lambda_expression
    (11) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (12) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (13) if_statement -> . IF LPAREN expression RPAREN block elseif_list else_block
    (21) function_definition -> . ZAP IDENTIFIER LPAREN parameter_list RPAREN block
    (25) return_statement -> . RETURN expression SEMICOLON
    (26) expression_statement -> . expression SEMICOLON
    (54) lambda_expression -> . IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    $end            reduce using rule 1 (program -> statement_list .)
    IDENTIFIER      shift and go to state 11
    PRINT           shift and go to state 13
    IF              shift and go to state 15
    ZAP             shift and go to state 16
    RETURN          shift and go to state 17
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    SEMICOLON       reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    statement                      shift and go to state 28
    assignment_statement           shift and go to state 4
    print_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    function_definition            shift and go to state 7
    return_statement               shift and go to state 8
    expression_statement           shift and go to state 9
    lambda_expression              shift and go to state 10
    expression                     shift and go to state 12
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 3

    (2) statement_list -> statement .

    IDENTIFIER      reduce using rule 2 (statement_list -> statement .)
    PRINT           reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    ZAP             reduce using rule 2 (statement_list -> statement .)
    RETURN          reduce using rule 2 (statement_list -> statement .)
    NUMBER          reduce using rule 2 (statement_list -> statement .)
    TRUE            reduce using rule 2 (statement_list -> statement .)
    FALSE           reduce using rule 2 (statement_list -> statement .)
    LPAREN          reduce using rule 2 (statement_list -> statement .)
    NOT             reduce using rule 2 (statement_list -> statement .)
    MINUS           reduce using rule 2 (statement_list -> statement .)
    LAMBDA          reduce using rule 2 (statement_list -> statement .)
    SEMICOLON       reduce using rule 2 (statement_list -> statement .)
    PLUS            reduce using rule 2 (statement_list -> statement .)
    TIMES           reduce using rule 2 (statement_list -> statement .)
    DIVIDE          reduce using rule 2 (statement_list -> statement .)
    MODULO          reduce using rule 2 (statement_list -> statement .)
    GT              reduce using rule 2 (statement_list -> statement .)
    LT              reduce using rule 2 (statement_list -> statement .)
    GE              reduce using rule 2 (statement_list -> statement .)
    LE              reduce using rule 2 (statement_list -> statement .)
    EQ              reduce using rule 2 (statement_list -> statement .)
    NEQ             reduce using rule 2 (statement_list -> statement .)
    AND             reduce using rule 2 (statement_list -> statement .)
    OR              reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACE          reduce using rule 2 (statement_list -> statement .)


state 4

    (4) statement -> assignment_statement .

    IDENTIFIER      reduce using rule 4 (statement -> assignment_statement .)
    PRINT           reduce using rule 4 (statement -> assignment_statement .)
    IF              reduce using rule 4 (statement -> assignment_statement .)
    ZAP             reduce using rule 4 (statement -> assignment_statement .)
    RETURN          reduce using rule 4 (statement -> assignment_statement .)
    NUMBER          reduce using rule 4 (statement -> assignment_statement .)
    TRUE            reduce using rule 4 (statement -> assignment_statement .)
    FALSE           reduce using rule 4 (statement -> assignment_statement .)
    LPAREN          reduce using rule 4 (statement -> assignment_statement .)
    NOT             reduce using rule 4 (statement -> assignment_statement .)
    MINUS           reduce using rule 4 (statement -> assignment_statement .)
    LAMBDA          reduce using rule 4 (statement -> assignment_statement .)
    SEMICOLON       reduce using rule 4 (statement -> assignment_statement .)
    PLUS            reduce using rule 4 (statement -> assignment_statement .)
    TIMES           reduce using rule 4 (statement -> assignment_statement .)
    DIVIDE          reduce using rule 4 (statement -> assignment_statement .)
    MODULO          reduce using rule 4 (statement -> assignment_statement .)
    GT              reduce using rule 4 (statement -> assignment_statement .)
    LT              reduce using rule 4 (statement -> assignment_statement .)
    GE              reduce using rule 4 (statement -> assignment_statement .)
    LE              reduce using rule 4 (statement -> assignment_statement .)
    EQ              reduce using rule 4 (statement -> assignment_statement .)
    NEQ             reduce using rule 4 (statement -> assignment_statement .)
    AND             reduce using rule 4 (statement -> assignment_statement .)
    OR              reduce using rule 4 (statement -> assignment_statement .)
    $end            reduce using rule 4 (statement -> assignment_statement .)
    RBRACE          reduce using rule 4 (statement -> assignment_statement .)


state 5

    (5) statement -> print_statement .

    IDENTIFIER      reduce using rule 5 (statement -> print_statement .)
    PRINT           reduce using rule 5 (statement -> print_statement .)
    IF              reduce using rule 5 (statement -> print_statement .)
    ZAP             reduce using rule 5 (statement -> print_statement .)
    RETURN          reduce using rule 5 (statement -> print_statement .)
    NUMBER          reduce using rule 5 (statement -> print_statement .)
    TRUE            reduce using rule 5 (statement -> print_statement .)
    FALSE           reduce using rule 5 (statement -> print_statement .)
    LPAREN          reduce using rule 5 (statement -> print_statement .)
    NOT             reduce using rule 5 (statement -> print_statement .)
    MINUS           reduce using rule 5 (statement -> print_statement .)
    LAMBDA          reduce using rule 5 (statement -> print_statement .)
    SEMICOLON       reduce using rule 5 (statement -> print_statement .)
    PLUS            reduce using rule 5 (statement -> print_statement .)
    TIMES           reduce using rule 5 (statement -> print_statement .)
    DIVIDE          reduce using rule 5 (statement -> print_statement .)
    MODULO          reduce using rule 5 (statement -> print_statement .)
    GT              reduce using rule 5 (statement -> print_statement .)
    LT              reduce using rule 5 (statement -> print_statement .)
    GE              reduce using rule 5 (statement -> print_statement .)
    LE              reduce using rule 5 (statement -> print_statement .)
    EQ              reduce using rule 5 (statement -> print_statement .)
    NEQ             reduce using rule 5 (statement -> print_statement .)
    AND             reduce using rule 5 (statement -> print_statement .)
    OR              reduce using rule 5 (statement -> print_statement .)
    $end            reduce using rule 5 (statement -> print_statement .)
    RBRACE          reduce using rule 5 (statement -> print_statement .)


state 6

    (6) statement -> if_statement .

    IDENTIFIER      reduce using rule 6 (statement -> if_statement .)
    PRINT           reduce using rule 6 (statement -> if_statement .)
    IF              reduce using rule 6 (statement -> if_statement .)
    ZAP             reduce using rule 6 (statement -> if_statement .)
    RETURN          reduce using rule 6 (statement -> if_statement .)
    NUMBER          reduce using rule 6 (statement -> if_statement .)
    TRUE            reduce using rule 6 (statement -> if_statement .)
    FALSE           reduce using rule 6 (statement -> if_statement .)
    LPAREN          reduce using rule 6 (statement -> if_statement .)
    NOT             reduce using rule 6 (statement -> if_statement .)
    MINUS           reduce using rule 6 (statement -> if_statement .)
    LAMBDA          reduce using rule 6 (statement -> if_statement .)
    SEMICOLON       reduce using rule 6 (statement -> if_statement .)
    PLUS            reduce using rule 6 (statement -> if_statement .)
    TIMES           reduce using rule 6 (statement -> if_statement .)
    DIVIDE          reduce using rule 6 (statement -> if_statement .)
    MODULO          reduce using rule 6 (statement -> if_statement .)
    GT              reduce using rule 6 (statement -> if_statement .)
    LT              reduce using rule 6 (statement -> if_statement .)
    GE              reduce using rule 6 (statement -> if_statement .)
    LE              reduce using rule 6 (statement -> if_statement .)
    EQ              reduce using rule 6 (statement -> if_statement .)
    NEQ             reduce using rule 6 (statement -> if_statement .)
    AND             reduce using rule 6 (statement -> if_statement .)
    OR              reduce using rule 6 (statement -> if_statement .)
    $end            reduce using rule 6 (statement -> if_statement .)
    RBRACE          reduce using rule 6 (statement -> if_statement .)


state 7

    (7) statement -> function_definition .

    IDENTIFIER      reduce using rule 7 (statement -> function_definition .)
    PRINT           reduce using rule 7 (statement -> function_definition .)
    IF              reduce using rule 7 (statement -> function_definition .)
    ZAP             reduce using rule 7 (statement -> function_definition .)
    RETURN          reduce using rule 7 (statement -> function_definition .)
    NUMBER          reduce using rule 7 (statement -> function_definition .)
    TRUE            reduce using rule 7 (statement -> function_definition .)
    FALSE           reduce using rule 7 (statement -> function_definition .)
    LPAREN          reduce using rule 7 (statement -> function_definition .)
    NOT             reduce using rule 7 (statement -> function_definition .)
    MINUS           reduce using rule 7 (statement -> function_definition .)
    LAMBDA          reduce using rule 7 (statement -> function_definition .)
    SEMICOLON       reduce using rule 7 (statement -> function_definition .)
    PLUS            reduce using rule 7 (statement -> function_definition .)
    TIMES           reduce using rule 7 (statement -> function_definition .)
    DIVIDE          reduce using rule 7 (statement -> function_definition .)
    MODULO          reduce using rule 7 (statement -> function_definition .)
    GT              reduce using rule 7 (statement -> function_definition .)
    LT              reduce using rule 7 (statement -> function_definition .)
    GE              reduce using rule 7 (statement -> function_definition .)
    LE              reduce using rule 7 (statement -> function_definition .)
    EQ              reduce using rule 7 (statement -> function_definition .)
    NEQ             reduce using rule 7 (statement -> function_definition .)
    AND             reduce using rule 7 (statement -> function_definition .)
    OR              reduce using rule 7 (statement -> function_definition .)
    $end            reduce using rule 7 (statement -> function_definition .)
    RBRACE          reduce using rule 7 (statement -> function_definition .)


state 8

    (8) statement -> return_statement .

    IDENTIFIER      reduce using rule 8 (statement -> return_statement .)
    PRINT           reduce using rule 8 (statement -> return_statement .)
    IF              reduce using rule 8 (statement -> return_statement .)
    ZAP             reduce using rule 8 (statement -> return_statement .)
    RETURN          reduce using rule 8 (statement -> return_statement .)
    NUMBER          reduce using rule 8 (statement -> return_statement .)
    TRUE            reduce using rule 8 (statement -> return_statement .)
    FALSE           reduce using rule 8 (statement -> return_statement .)
    LPAREN          reduce using rule 8 (statement -> return_statement .)
    NOT             reduce using rule 8 (statement -> return_statement .)
    MINUS           reduce using rule 8 (statement -> return_statement .)
    LAMBDA          reduce using rule 8 (statement -> return_statement .)
    SEMICOLON       reduce using rule 8 (statement -> return_statement .)
    PLUS            reduce using rule 8 (statement -> return_statement .)
    TIMES           reduce using rule 8 (statement -> return_statement .)
    DIVIDE          reduce using rule 8 (statement -> return_statement .)
    MODULO          reduce using rule 8 (statement -> return_statement .)
    GT              reduce using rule 8 (statement -> return_statement .)
    LT              reduce using rule 8 (statement -> return_statement .)
    GE              reduce using rule 8 (statement -> return_statement .)
    LE              reduce using rule 8 (statement -> return_statement .)
    EQ              reduce using rule 8 (statement -> return_statement .)
    NEQ             reduce using rule 8 (statement -> return_statement .)
    AND             reduce using rule 8 (statement -> return_statement .)
    OR              reduce using rule 8 (statement -> return_statement .)
    $end            reduce using rule 8 (statement -> return_statement .)
    RBRACE          reduce using rule 8 (statement -> return_statement .)


state 9

    (9) statement -> expression_statement .

    IDENTIFIER      reduce using rule 9 (statement -> expression_statement .)
    PRINT           reduce using rule 9 (statement -> expression_statement .)
    IF              reduce using rule 9 (statement -> expression_statement .)
    ZAP             reduce using rule 9 (statement -> expression_statement .)
    RETURN          reduce using rule 9 (statement -> expression_statement .)
    NUMBER          reduce using rule 9 (statement -> expression_statement .)
    TRUE            reduce using rule 9 (statement -> expression_statement .)
    FALSE           reduce using rule 9 (statement -> expression_statement .)
    LPAREN          reduce using rule 9 (statement -> expression_statement .)
    NOT             reduce using rule 9 (statement -> expression_statement .)
    MINUS           reduce using rule 9 (statement -> expression_statement .)
    LAMBDA          reduce using rule 9 (statement -> expression_statement .)
    SEMICOLON       reduce using rule 9 (statement -> expression_statement .)
    PLUS            reduce using rule 9 (statement -> expression_statement .)
    TIMES           reduce using rule 9 (statement -> expression_statement .)
    DIVIDE          reduce using rule 9 (statement -> expression_statement .)
    MODULO          reduce using rule 9 (statement -> expression_statement .)
    GT              reduce using rule 9 (statement -> expression_statement .)
    LT              reduce using rule 9 (statement -> expression_statement .)
    GE              reduce using rule 9 (statement -> expression_statement .)
    LE              reduce using rule 9 (statement -> expression_statement .)
    EQ              reduce using rule 9 (statement -> expression_statement .)
    NEQ             reduce using rule 9 (statement -> expression_statement .)
    AND             reduce using rule 9 (statement -> expression_statement .)
    OR              reduce using rule 9 (statement -> expression_statement .)
    $end            reduce using rule 9 (statement -> expression_statement .)
    RBRACE          reduce using rule 9 (statement -> expression_statement .)


state 10

    (10) statement -> lambda_expression .

    IDENTIFIER      reduce using rule 10 (statement -> lambda_expression .)
    PRINT           reduce using rule 10 (statement -> lambda_expression .)
    IF              reduce using rule 10 (statement -> lambda_expression .)
    ZAP             reduce using rule 10 (statement -> lambda_expression .)
    RETURN          reduce using rule 10 (statement -> lambda_expression .)
    NUMBER          reduce using rule 10 (statement -> lambda_expression .)
    TRUE            reduce using rule 10 (statement -> lambda_expression .)
    FALSE           reduce using rule 10 (statement -> lambda_expression .)
    LPAREN          reduce using rule 10 (statement -> lambda_expression .)
    NOT             reduce using rule 10 (statement -> lambda_expression .)
    MINUS           reduce using rule 10 (statement -> lambda_expression .)
    LAMBDA          reduce using rule 10 (statement -> lambda_expression .)
    SEMICOLON       reduce using rule 10 (statement -> lambda_expression .)
    PLUS            reduce using rule 10 (statement -> lambda_expression .)
    TIMES           reduce using rule 10 (statement -> lambda_expression .)
    DIVIDE          reduce using rule 10 (statement -> lambda_expression .)
    MODULO          reduce using rule 10 (statement -> lambda_expression .)
    GT              reduce using rule 10 (statement -> lambda_expression .)
    LT              reduce using rule 10 (statement -> lambda_expression .)
    GE              reduce using rule 10 (statement -> lambda_expression .)
    LE              reduce using rule 10 (statement -> lambda_expression .)
    EQ              reduce using rule 10 (statement -> lambda_expression .)
    NEQ             reduce using rule 10 (statement -> lambda_expression .)
    AND             reduce using rule 10 (statement -> lambda_expression .)
    OR              reduce using rule 10 (statement -> lambda_expression .)
    $end            reduce using rule 10 (statement -> lambda_expression .)
    RBRACE          reduce using rule 10 (statement -> lambda_expression .)


state 11

    (11) assignment_statement -> IDENTIFIER . ASSIGN expression SEMICOLON
    (54) lambda_expression -> IDENTIFIER . ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON
    (28) expression -> IDENTIFIER .
    (57) function_call -> IDENTIFIER . LPAREN argument_list RPAREN
    (56) lambda_call -> IDENTIFIER . LBRACE argument_list RBRACE

    ASSIGN          shift and go to state 29
    SEMICOLON       reduce using rule 28 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 28 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 28 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 28 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 28 (expression -> IDENTIFIER .)
    MODULO          reduce using rule 28 (expression -> IDENTIFIER .)
    GT              reduce using rule 28 (expression -> IDENTIFIER .)
    LT              reduce using rule 28 (expression -> IDENTIFIER .)
    GE              reduce using rule 28 (expression -> IDENTIFIER .)
    LE              reduce using rule 28 (expression -> IDENTIFIER .)
    EQ              reduce using rule 28 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 28 (expression -> IDENTIFIER .)
    AND             reduce using rule 28 (expression -> IDENTIFIER .)
    OR              reduce using rule 28 (expression -> IDENTIFIER .)
    LPAREN          shift and go to state 30
    LBRACE          shift and go to state 31


state 12

    (26) expression_statement -> expression . SEMICOLON
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       shift and go to state 32
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 13

    (12) print_statement -> PRINT . LPAREN expression RPAREN SEMICOLON

    LPAREN          shift and go to state 46


state 14

    (31) expression -> LPAREN . expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    RPAREN          reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 47
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 15

    (13) if_statement -> IF . LPAREN expression RPAREN block elseif_list else_block

    LPAREN          shift and go to state 49


state 16

    (21) function_definition -> ZAP . IDENTIFIER LPAREN parameter_list RPAREN block

    IDENTIFIER      shift and go to state 50


state 17

    (25) return_statement -> RETURN . expression SEMICOLON
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    SEMICOLON       reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 51
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 18

    (55) anonymous_function -> LAMBDA . LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE

    LPAREN          shift and go to state 52


state 19

    (27) expression -> NUMBER .

    SEMICOLON       reduce using rule 27 (expression -> NUMBER .)
    PLUS            reduce using rule 27 (expression -> NUMBER .)
    MINUS           reduce using rule 27 (expression -> NUMBER .)
    TIMES           reduce using rule 27 (expression -> NUMBER .)
    DIVIDE          reduce using rule 27 (expression -> NUMBER .)
    MODULO          reduce using rule 27 (expression -> NUMBER .)
    GT              reduce using rule 27 (expression -> NUMBER .)
    LT              reduce using rule 27 (expression -> NUMBER .)
    GE              reduce using rule 27 (expression -> NUMBER .)
    LE              reduce using rule 27 (expression -> NUMBER .)
    EQ              reduce using rule 27 (expression -> NUMBER .)
    NEQ             reduce using rule 27 (expression -> NUMBER .)
    AND             reduce using rule 27 (expression -> NUMBER .)
    OR              reduce using rule 27 (expression -> NUMBER .)
    RPAREN          reduce using rule 27 (expression -> NUMBER .)
    COMMA           reduce using rule 27 (expression -> NUMBER .)
    RBRACE          reduce using rule 27 (expression -> NUMBER .)


state 20

    (29) expression -> TRUE .

    SEMICOLON       reduce using rule 29 (expression -> TRUE .)
    PLUS            reduce using rule 29 (expression -> TRUE .)
    MINUS           reduce using rule 29 (expression -> TRUE .)
    TIMES           reduce using rule 29 (expression -> TRUE .)
    DIVIDE          reduce using rule 29 (expression -> TRUE .)
    MODULO          reduce using rule 29 (expression -> TRUE .)
    GT              reduce using rule 29 (expression -> TRUE .)
    LT              reduce using rule 29 (expression -> TRUE .)
    GE              reduce using rule 29 (expression -> TRUE .)
    LE              reduce using rule 29 (expression -> TRUE .)
    EQ              reduce using rule 29 (expression -> TRUE .)
    NEQ             reduce using rule 29 (expression -> TRUE .)
    AND             reduce using rule 29 (expression -> TRUE .)
    OR              reduce using rule 29 (expression -> TRUE .)
    RPAREN          reduce using rule 29 (expression -> TRUE .)
    COMMA           reduce using rule 29 (expression -> TRUE .)
    RBRACE          reduce using rule 29 (expression -> TRUE .)


state 21

    (30) expression -> FALSE .

    SEMICOLON       reduce using rule 30 (expression -> FALSE .)
    PLUS            reduce using rule 30 (expression -> FALSE .)
    MINUS           reduce using rule 30 (expression -> FALSE .)
    TIMES           reduce using rule 30 (expression -> FALSE .)
    DIVIDE          reduce using rule 30 (expression -> FALSE .)
    MODULO          reduce using rule 30 (expression -> FALSE .)
    GT              reduce using rule 30 (expression -> FALSE .)
    LT              reduce using rule 30 (expression -> FALSE .)
    GE              reduce using rule 30 (expression -> FALSE .)
    LE              reduce using rule 30 (expression -> FALSE .)
    EQ              reduce using rule 30 (expression -> FALSE .)
    NEQ             reduce using rule 30 (expression -> FALSE .)
    AND             reduce using rule 30 (expression -> FALSE .)
    OR              reduce using rule 30 (expression -> FALSE .)
    RPAREN          reduce using rule 30 (expression -> FALSE .)
    COMMA           reduce using rule 30 (expression -> FALSE .)
    RBRACE          reduce using rule 30 (expression -> FALSE .)


state 22

    (46) expression -> MINUS . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 53
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 23

    (45) expression -> NOT . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 54
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 24

    (47) expression -> function_call .

    SEMICOLON       reduce using rule 47 (expression -> function_call .)
    PLUS            reduce using rule 47 (expression -> function_call .)
    MINUS           reduce using rule 47 (expression -> function_call .)
    TIMES           reduce using rule 47 (expression -> function_call .)
    DIVIDE          reduce using rule 47 (expression -> function_call .)
    MODULO          reduce using rule 47 (expression -> function_call .)
    GT              reduce using rule 47 (expression -> function_call .)
    LT              reduce using rule 47 (expression -> function_call .)
    GE              reduce using rule 47 (expression -> function_call .)
    LE              reduce using rule 47 (expression -> function_call .)
    EQ              reduce using rule 47 (expression -> function_call .)
    NEQ             reduce using rule 47 (expression -> function_call .)
    AND             reduce using rule 47 (expression -> function_call .)
    OR              reduce using rule 47 (expression -> function_call .)
    RPAREN          reduce using rule 47 (expression -> function_call .)
    COMMA           reduce using rule 47 (expression -> function_call .)
    RBRACE          reduce using rule 47 (expression -> function_call .)


state 25

    (48) expression -> anonymous_function .

    SEMICOLON       reduce using rule 48 (expression -> anonymous_function .)
    PLUS            reduce using rule 48 (expression -> anonymous_function .)
    MINUS           reduce using rule 48 (expression -> anonymous_function .)
    TIMES           reduce using rule 48 (expression -> anonymous_function .)
    DIVIDE          reduce using rule 48 (expression -> anonymous_function .)
    MODULO          reduce using rule 48 (expression -> anonymous_function .)
    GT              reduce using rule 48 (expression -> anonymous_function .)
    LT              reduce using rule 48 (expression -> anonymous_function .)
    GE              reduce using rule 48 (expression -> anonymous_function .)
    LE              reduce using rule 48 (expression -> anonymous_function .)
    EQ              reduce using rule 48 (expression -> anonymous_function .)
    NEQ             reduce using rule 48 (expression -> anonymous_function .)
    AND             reduce using rule 48 (expression -> anonymous_function .)
    OR              reduce using rule 48 (expression -> anonymous_function .)
    RPAREN          reduce using rule 48 (expression -> anonymous_function .)
    COMMA           reduce using rule 48 (expression -> anonymous_function .)
    RBRACE          reduce using rule 48 (expression -> anonymous_function .)


state 26

    (49) expression -> lambda_call .

    SEMICOLON       reduce using rule 49 (expression -> lambda_call .)
    PLUS            reduce using rule 49 (expression -> lambda_call .)
    MINUS           reduce using rule 49 (expression -> lambda_call .)
    TIMES           reduce using rule 49 (expression -> lambda_call .)
    DIVIDE          reduce using rule 49 (expression -> lambda_call .)
    MODULO          reduce using rule 49 (expression -> lambda_call .)
    GT              reduce using rule 49 (expression -> lambda_call .)
    LT              reduce using rule 49 (expression -> lambda_call .)
    GE              reduce using rule 49 (expression -> lambda_call .)
    LE              reduce using rule 49 (expression -> lambda_call .)
    EQ              reduce using rule 49 (expression -> lambda_call .)
    NEQ             reduce using rule 49 (expression -> lambda_call .)
    AND             reduce using rule 49 (expression -> lambda_call .)
    OR              reduce using rule 49 (expression -> lambda_call .)
    RPAREN          reduce using rule 49 (expression -> lambda_call .)
    COMMA           reduce using rule 49 (expression -> lambda_call .)
    RBRACE          reduce using rule 49 (expression -> lambda_call .)


state 27

    (50) expression -> empty .

    SEMICOLON       reduce using rule 50 (expression -> empty .)
    PLUS            reduce using rule 50 (expression -> empty .)
    MINUS           reduce using rule 50 (expression -> empty .)
    TIMES           reduce using rule 50 (expression -> empty .)
    DIVIDE          reduce using rule 50 (expression -> empty .)
    MODULO          reduce using rule 50 (expression -> empty .)
    GT              reduce using rule 50 (expression -> empty .)
    LT              reduce using rule 50 (expression -> empty .)
    GE              reduce using rule 50 (expression -> empty .)
    LE              reduce using rule 50 (expression -> empty .)
    EQ              reduce using rule 50 (expression -> empty .)
    NEQ             reduce using rule 50 (expression -> empty .)
    AND             reduce using rule 50 (expression -> empty .)
    OR              reduce using rule 50 (expression -> empty .)
    RPAREN          reduce using rule 50 (expression -> empty .)
    COMMA           reduce using rule 50 (expression -> empty .)
    RBRACE          reduce using rule 50 (expression -> empty .)


state 28

    (3) statement_list -> statement_list statement .

    IDENTIFIER      reduce using rule 3 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    ZAP             reduce using rule 3 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 3 (statement_list -> statement_list statement .)
    NUMBER          reduce using rule 3 (statement_list -> statement_list statement .)
    TRUE            reduce using rule 3 (statement_list -> statement_list statement .)
    FALSE           reduce using rule 3 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 3 (statement_list -> statement_list statement .)
    NOT             reduce using rule 3 (statement_list -> statement_list statement .)
    MINUS           reduce using rule 3 (statement_list -> statement_list statement .)
    LAMBDA          reduce using rule 3 (statement_list -> statement_list statement .)
    SEMICOLON       reduce using rule 3 (statement_list -> statement_list statement .)
    PLUS            reduce using rule 3 (statement_list -> statement_list statement .)
    TIMES           reduce using rule 3 (statement_list -> statement_list statement .)
    DIVIDE          reduce using rule 3 (statement_list -> statement_list statement .)
    MODULO          reduce using rule 3 (statement_list -> statement_list statement .)
    GT              reduce using rule 3 (statement_list -> statement_list statement .)
    LT              reduce using rule 3 (statement_list -> statement_list statement .)
    GE              reduce using rule 3 (statement_list -> statement_list statement .)
    LE              reduce using rule 3 (statement_list -> statement_list statement .)
    EQ              reduce using rule 3 (statement_list -> statement_list statement .)
    NEQ             reduce using rule 3 (statement_list -> statement_list statement .)
    AND             reduce using rule 3 (statement_list -> statement_list statement .)
    OR              reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)
    RBRACE          reduce using rule 3 (statement_list -> statement_list statement .)


state 29

    (11) assignment_statement -> IDENTIFIER ASSIGN . expression SEMICOLON
    (54) lambda_expression -> IDENTIFIER ASSIGN . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    LAMBDA          shift and go to state 56
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    SEMICOLON       reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 55
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 30

    (57) function_call -> IDENTIFIER LPAREN . argument_list RPAREN
    (51) argument_list -> . expression
    (52) argument_list -> . argument_list COMMA expression
    (53) argument_list -> . empty
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (58) empty -> .
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    LAMBDA          shift and go to state 18

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    argument_list                  shift and go to state 57
    expression                     shift and go to state 58
    empty                          shift and go to state 59
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26

state 31

    (56) lambda_call -> IDENTIFIER LBRACE . argument_list RBRACE
    (51) argument_list -> . expression
    (52) argument_list -> . argument_list COMMA expression
    (53) argument_list -> . empty
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (58) empty -> .
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    RBRACE          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    LAMBDA          shift and go to state 18

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    argument_list                  shift and go to state 60
    expression                     shift and go to state 58
    empty                          shift and go to state 59
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26

state 32

    (26) expression_statement -> expression SEMICOLON .

    IDENTIFIER      reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    PRINT           reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    IF              reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    ZAP             reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    RETURN          reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    NUMBER          reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    TRUE            reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    FALSE           reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    NOT             reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    MINUS           reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    LAMBDA          reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    PLUS            reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    TIMES           reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    DIVIDE          reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    MODULO          reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    GT              reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    LT              reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    GE              reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    LE              reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    EQ              reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    NEQ             reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    AND             reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    OR              reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    $end            reduce using rule 26 (expression_statement -> expression SEMICOLON .)
    RBRACE          reduce using rule 26 (expression_statement -> expression SEMICOLON .)


state 33

    (32) expression -> expression PLUS . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 61
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 34

    (33) expression -> expression MINUS . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 62
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 35

    (34) expression -> expression TIMES . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 63
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 36

    (35) expression -> expression DIVIDE . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 64
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 37

    (36) expression -> expression MODULO . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 65
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 38

    (37) expression -> expression GT . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 66
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 39

    (38) expression -> expression LT . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 67
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 40

    (39) expression -> expression GE . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 68
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 41

    (40) expression -> expression LE . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 69
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 42

    (41) expression -> expression EQ . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 70
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 43

    (42) expression -> expression NEQ . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 71
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 44

    (43) expression -> expression AND . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 72
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 45

    (44) expression -> expression OR . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 73
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 46

    (12) print_statement -> PRINT LPAREN . expression RPAREN SEMICOLON
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    RPAREN          reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 74
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 47

    (31) expression -> LPAREN expression . RPAREN
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RPAREN          shift and go to state 75
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 48

    (28) expression -> IDENTIFIER .
    (57) function_call -> IDENTIFIER . LPAREN argument_list RPAREN
    (56) lambda_call -> IDENTIFIER . LBRACE argument_list RBRACE

    RPAREN          reduce using rule 28 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 28 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 28 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 28 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 28 (expression -> IDENTIFIER .)
    MODULO          reduce using rule 28 (expression -> IDENTIFIER .)
    GT              reduce using rule 28 (expression -> IDENTIFIER .)
    LT              reduce using rule 28 (expression -> IDENTIFIER .)
    GE              reduce using rule 28 (expression -> IDENTIFIER .)
    LE              reduce using rule 28 (expression -> IDENTIFIER .)
    EQ              reduce using rule 28 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 28 (expression -> IDENTIFIER .)
    AND             reduce using rule 28 (expression -> IDENTIFIER .)
    OR              reduce using rule 28 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 28 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 28 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 28 (expression -> IDENTIFIER .)
    LPAREN          shift and go to state 30
    LBRACE          shift and go to state 31


state 49

    (13) if_statement -> IF LPAREN . expression RPAREN block elseif_list else_block
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    RPAREN          reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 76
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 50

    (21) function_definition -> ZAP IDENTIFIER . LPAREN parameter_list RPAREN block

    LPAREN          shift and go to state 77


state 51

    (25) return_statement -> RETURN expression . SEMICOLON
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       shift and go to state 78
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 52

    (55) anonymous_function -> LAMBDA LPAREN . parameter_list RPAREN COLON LBRACE expression RBRACE
    (22) parameter_list -> . IDENTIFIER
    (23) parameter_list -> . parameter_list COMMA IDENTIFIER
    (24) parameter_list -> . empty
    (58) empty -> .

    IDENTIFIER      shift and go to state 80
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)

    parameter_list                 shift and go to state 79
    empty                          shift and go to state 81

state 53

    (46) expression -> MINUS expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 46 (expression -> MINUS expression .)
    PLUS            reduce using rule 46 (expression -> MINUS expression .)
    MINUS           reduce using rule 46 (expression -> MINUS expression .)
    TIMES           reduce using rule 46 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 46 (expression -> MINUS expression .)
    MODULO          reduce using rule 46 (expression -> MINUS expression .)
    GT              reduce using rule 46 (expression -> MINUS expression .)
    LT              reduce using rule 46 (expression -> MINUS expression .)
    GE              reduce using rule 46 (expression -> MINUS expression .)
    LE              reduce using rule 46 (expression -> MINUS expression .)
    EQ              reduce using rule 46 (expression -> MINUS expression .)
    NEQ             reduce using rule 46 (expression -> MINUS expression .)
    AND             reduce using rule 46 (expression -> MINUS expression .)
    OR              reduce using rule 46 (expression -> MINUS expression .)
    RPAREN          reduce using rule 46 (expression -> MINUS expression .)
    COMMA           reduce using rule 46 (expression -> MINUS expression .)
    RBRACE          reduce using rule 46 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! TIMES           [ shift and go to state 35 ]
  ! DIVIDE          [ shift and go to state 36 ]
  ! MODULO          [ shift and go to state 37 ]
  ! GT              [ shift and go to state 38 ]
  ! LT              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 40 ]
  ! LE              [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 54

    (45) expression -> NOT expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 45 (expression -> NOT expression .)
    PLUS            reduce using rule 45 (expression -> NOT expression .)
    MINUS           reduce using rule 45 (expression -> NOT expression .)
    TIMES           reduce using rule 45 (expression -> NOT expression .)
    DIVIDE          reduce using rule 45 (expression -> NOT expression .)
    MODULO          reduce using rule 45 (expression -> NOT expression .)
    GT              reduce using rule 45 (expression -> NOT expression .)
    LT              reduce using rule 45 (expression -> NOT expression .)
    GE              reduce using rule 45 (expression -> NOT expression .)
    LE              reduce using rule 45 (expression -> NOT expression .)
    EQ              reduce using rule 45 (expression -> NOT expression .)
    NEQ             reduce using rule 45 (expression -> NOT expression .)
    AND             reduce using rule 45 (expression -> NOT expression .)
    OR              reduce using rule 45 (expression -> NOT expression .)
    RPAREN          reduce using rule 45 (expression -> NOT expression .)
    COMMA           reduce using rule 45 (expression -> NOT expression .)
    RBRACE          reduce using rule 45 (expression -> NOT expression .)

  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! TIMES           [ shift and go to state 35 ]
  ! DIVIDE          [ shift and go to state 36 ]
  ! MODULO          [ shift and go to state 37 ]
  ! GT              [ shift and go to state 38 ]
  ! LT              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 40 ]
  ! LE              [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 55

    (11) assignment_statement -> IDENTIFIER ASSIGN expression . SEMICOLON
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       shift and go to state 82
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 56

    (54) lambda_expression -> IDENTIFIER ASSIGN LAMBDA . LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON
    (55) anonymous_function -> LAMBDA . LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE

    LPAREN          shift and go to state 83


state 57

    (57) function_call -> IDENTIFIER LPAREN argument_list . RPAREN
    (52) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 84
    COMMA           shift and go to state 85


state 58

    (51) argument_list -> expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RPAREN          reduce using rule 51 (argument_list -> expression .)
    COMMA           reduce using rule 51 (argument_list -> expression .)
    RBRACE          reduce using rule 51 (argument_list -> expression .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 59

    (53) argument_list -> empty .
    (50) expression -> empty .

  ! reduce/reduce conflict for RPAREN resolved using rule 50 (expression -> empty .)
  ! reduce/reduce conflict for COMMA resolved using rule 50 (expression -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 50 (expression -> empty .)
    PLUS            reduce using rule 50 (expression -> empty .)
    MINUS           reduce using rule 50 (expression -> empty .)
    TIMES           reduce using rule 50 (expression -> empty .)
    DIVIDE          reduce using rule 50 (expression -> empty .)
    MODULO          reduce using rule 50 (expression -> empty .)
    GT              reduce using rule 50 (expression -> empty .)
    LT              reduce using rule 50 (expression -> empty .)
    GE              reduce using rule 50 (expression -> empty .)
    LE              reduce using rule 50 (expression -> empty .)
    EQ              reduce using rule 50 (expression -> empty .)
    NEQ             reduce using rule 50 (expression -> empty .)
    AND             reduce using rule 50 (expression -> empty .)
    OR              reduce using rule 50 (expression -> empty .)
    RPAREN          reduce using rule 50 (expression -> empty .)
    COMMA           reduce using rule 50 (expression -> empty .)
    RBRACE          reduce using rule 50 (expression -> empty .)

  ! RPAREN          [ reduce using rule 53 (argument_list -> empty .) ]
  ! COMMA           [ reduce using rule 53 (argument_list -> empty .) ]
  ! RBRACE          [ reduce using rule 53 (argument_list -> empty .) ]


state 60

    (56) lambda_call -> IDENTIFIER LBRACE argument_list . RBRACE
    (52) argument_list -> argument_list . COMMA expression

    RBRACE          shift and go to state 86
    COMMA           shift and go to state 85


state 61

    (32) expression -> expression PLUS expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 32 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 32 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 32 (expression -> expression PLUS expression .)
    GT              reduce using rule 32 (expression -> expression PLUS expression .)
    LT              reduce using rule 32 (expression -> expression PLUS expression .)
    GE              reduce using rule 32 (expression -> expression PLUS expression .)
    LE              reduce using rule 32 (expression -> expression PLUS expression .)
    EQ              reduce using rule 32 (expression -> expression PLUS expression .)
    NEQ             reduce using rule 32 (expression -> expression PLUS expression .)
    AND             reduce using rule 32 (expression -> expression PLUS expression .)
    OR              reduce using rule 32 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 32 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 32 (expression -> expression PLUS expression .)
    RBRACE          reduce using rule 32 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37

  ! TIMES           [ reduce using rule 32 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 32 (expression -> expression PLUS expression .) ]
  ! MODULO          [ reduce using rule 32 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! GT              [ shift and go to state 38 ]
  ! LT              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 40 ]
  ! LE              [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 62

    (33) expression -> expression MINUS expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 33 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 33 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 33 (expression -> expression MINUS expression .)
    GT              reduce using rule 33 (expression -> expression MINUS expression .)
    LT              reduce using rule 33 (expression -> expression MINUS expression .)
    GE              reduce using rule 33 (expression -> expression MINUS expression .)
    LE              reduce using rule 33 (expression -> expression MINUS expression .)
    EQ              reduce using rule 33 (expression -> expression MINUS expression .)
    NEQ             reduce using rule 33 (expression -> expression MINUS expression .)
    AND             reduce using rule 33 (expression -> expression MINUS expression .)
    OR              reduce using rule 33 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 33 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 33 (expression -> expression MINUS expression .)
    RBRACE          reduce using rule 33 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37

  ! TIMES           [ reduce using rule 33 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 33 (expression -> expression MINUS expression .) ]
  ! MODULO          [ reduce using rule 33 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! GT              [ shift and go to state 38 ]
  ! LT              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 40 ]
  ! LE              [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 63

    (34) expression -> expression TIMES expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 34 (expression -> expression TIMES expression .)
    PLUS            reduce using rule 34 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 34 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 34 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 34 (expression -> expression TIMES expression .)
    MODULO          reduce using rule 34 (expression -> expression TIMES expression .)
    GT              reduce using rule 34 (expression -> expression TIMES expression .)
    LT              reduce using rule 34 (expression -> expression TIMES expression .)
    GE              reduce using rule 34 (expression -> expression TIMES expression .)
    LE              reduce using rule 34 (expression -> expression TIMES expression .)
    EQ              reduce using rule 34 (expression -> expression TIMES expression .)
    NEQ             reduce using rule 34 (expression -> expression TIMES expression .)
    AND             reduce using rule 34 (expression -> expression TIMES expression .)
    OR              reduce using rule 34 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 34 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 34 (expression -> expression TIMES expression .)
    RBRACE          reduce using rule 34 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! TIMES           [ shift and go to state 35 ]
  ! DIVIDE          [ shift and go to state 36 ]
  ! MODULO          [ shift and go to state 37 ]
  ! GT              [ shift and go to state 38 ]
  ! LT              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 40 ]
  ! LE              [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 64

    (35) expression -> expression DIVIDE expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 35 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 35 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 35 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 35 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 35 (expression -> expression DIVIDE expression .)
    MODULO          reduce using rule 35 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 35 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 35 (expression -> expression DIVIDE expression .)
    GE              reduce using rule 35 (expression -> expression DIVIDE expression .)
    LE              reduce using rule 35 (expression -> expression DIVIDE expression .)
    EQ              reduce using rule 35 (expression -> expression DIVIDE expression .)
    NEQ             reduce using rule 35 (expression -> expression DIVIDE expression .)
    AND             reduce using rule 35 (expression -> expression DIVIDE expression .)
    OR              reduce using rule 35 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 35 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 35 (expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 35 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! TIMES           [ shift and go to state 35 ]
  ! DIVIDE          [ shift and go to state 36 ]
  ! MODULO          [ shift and go to state 37 ]
  ! GT              [ shift and go to state 38 ]
  ! LT              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 40 ]
  ! LE              [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 65

    (36) expression -> expression MODULO expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 36 (expression -> expression MODULO expression .)
    PLUS            reduce using rule 36 (expression -> expression MODULO expression .)
    MINUS           reduce using rule 36 (expression -> expression MODULO expression .)
    TIMES           reduce using rule 36 (expression -> expression MODULO expression .)
    DIVIDE          reduce using rule 36 (expression -> expression MODULO expression .)
    MODULO          reduce using rule 36 (expression -> expression MODULO expression .)
    GT              reduce using rule 36 (expression -> expression MODULO expression .)
    LT              reduce using rule 36 (expression -> expression MODULO expression .)
    GE              reduce using rule 36 (expression -> expression MODULO expression .)
    LE              reduce using rule 36 (expression -> expression MODULO expression .)
    EQ              reduce using rule 36 (expression -> expression MODULO expression .)
    NEQ             reduce using rule 36 (expression -> expression MODULO expression .)
    AND             reduce using rule 36 (expression -> expression MODULO expression .)
    OR              reduce using rule 36 (expression -> expression MODULO expression .)
    RPAREN          reduce using rule 36 (expression -> expression MODULO expression .)
    COMMA           reduce using rule 36 (expression -> expression MODULO expression .)
    RBRACE          reduce using rule 36 (expression -> expression MODULO expression .)

  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! TIMES           [ shift and go to state 35 ]
  ! DIVIDE          [ shift and go to state 36 ]
  ! MODULO          [ shift and go to state 37 ]
  ! GT              [ shift and go to state 38 ]
  ! LT              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 40 ]
  ! LE              [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 66

    (37) expression -> expression GT expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 37 (expression -> expression GT expression .)
    GT              reduce using rule 37 (expression -> expression GT expression .)
    LT              reduce using rule 37 (expression -> expression GT expression .)
    GE              reduce using rule 37 (expression -> expression GT expression .)
    LE              reduce using rule 37 (expression -> expression GT expression .)
    EQ              reduce using rule 37 (expression -> expression GT expression .)
    NEQ             reduce using rule 37 (expression -> expression GT expression .)
    AND             reduce using rule 37 (expression -> expression GT expression .)
    OR              reduce using rule 37 (expression -> expression GT expression .)
    RPAREN          reduce using rule 37 (expression -> expression GT expression .)
    COMMA           reduce using rule 37 (expression -> expression GT expression .)
    RBRACE          reduce using rule 37 (expression -> expression GT expression .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37

  ! PLUS            [ reduce using rule 37 (expression -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 37 (expression -> expression GT expression .) ]
  ! TIMES           [ reduce using rule 37 (expression -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 37 (expression -> expression GT expression .) ]
  ! MODULO          [ reduce using rule 37 (expression -> expression GT expression .) ]
  ! GT              [ shift and go to state 38 ]
  ! LT              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 40 ]
  ! LE              [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 67

    (38) expression -> expression LT expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 38 (expression -> expression LT expression .)
    GT              reduce using rule 38 (expression -> expression LT expression .)
    LT              reduce using rule 38 (expression -> expression LT expression .)
    GE              reduce using rule 38 (expression -> expression LT expression .)
    LE              reduce using rule 38 (expression -> expression LT expression .)
    EQ              reduce using rule 38 (expression -> expression LT expression .)
    NEQ             reduce using rule 38 (expression -> expression LT expression .)
    AND             reduce using rule 38 (expression -> expression LT expression .)
    OR              reduce using rule 38 (expression -> expression LT expression .)
    RPAREN          reduce using rule 38 (expression -> expression LT expression .)
    COMMA           reduce using rule 38 (expression -> expression LT expression .)
    RBRACE          reduce using rule 38 (expression -> expression LT expression .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37

  ! PLUS            [ reduce using rule 38 (expression -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 38 (expression -> expression LT expression .) ]
  ! TIMES           [ reduce using rule 38 (expression -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 38 (expression -> expression LT expression .) ]
  ! MODULO          [ reduce using rule 38 (expression -> expression LT expression .) ]
  ! GT              [ shift and go to state 38 ]
  ! LT              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 40 ]
  ! LE              [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 68

    (39) expression -> expression GE expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 39 (expression -> expression GE expression .)
    GT              reduce using rule 39 (expression -> expression GE expression .)
    LT              reduce using rule 39 (expression -> expression GE expression .)
    GE              reduce using rule 39 (expression -> expression GE expression .)
    LE              reduce using rule 39 (expression -> expression GE expression .)
    EQ              reduce using rule 39 (expression -> expression GE expression .)
    NEQ             reduce using rule 39 (expression -> expression GE expression .)
    AND             reduce using rule 39 (expression -> expression GE expression .)
    OR              reduce using rule 39 (expression -> expression GE expression .)
    RPAREN          reduce using rule 39 (expression -> expression GE expression .)
    COMMA           reduce using rule 39 (expression -> expression GE expression .)
    RBRACE          reduce using rule 39 (expression -> expression GE expression .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37

  ! PLUS            [ reduce using rule 39 (expression -> expression GE expression .) ]
  ! MINUS           [ reduce using rule 39 (expression -> expression GE expression .) ]
  ! TIMES           [ reduce using rule 39 (expression -> expression GE expression .) ]
  ! DIVIDE          [ reduce using rule 39 (expression -> expression GE expression .) ]
  ! MODULO          [ reduce using rule 39 (expression -> expression GE expression .) ]
  ! GT              [ shift and go to state 38 ]
  ! LT              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 40 ]
  ! LE              [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 69

    (40) expression -> expression LE expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 40 (expression -> expression LE expression .)
    GT              reduce using rule 40 (expression -> expression LE expression .)
    LT              reduce using rule 40 (expression -> expression LE expression .)
    GE              reduce using rule 40 (expression -> expression LE expression .)
    LE              reduce using rule 40 (expression -> expression LE expression .)
    EQ              reduce using rule 40 (expression -> expression LE expression .)
    NEQ             reduce using rule 40 (expression -> expression LE expression .)
    AND             reduce using rule 40 (expression -> expression LE expression .)
    OR              reduce using rule 40 (expression -> expression LE expression .)
    RPAREN          reduce using rule 40 (expression -> expression LE expression .)
    COMMA           reduce using rule 40 (expression -> expression LE expression .)
    RBRACE          reduce using rule 40 (expression -> expression LE expression .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37

  ! PLUS            [ reduce using rule 40 (expression -> expression LE expression .) ]
  ! MINUS           [ reduce using rule 40 (expression -> expression LE expression .) ]
  ! TIMES           [ reduce using rule 40 (expression -> expression LE expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression -> expression LE expression .) ]
  ! MODULO          [ reduce using rule 40 (expression -> expression LE expression .) ]
  ! GT              [ shift and go to state 38 ]
  ! LT              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 40 ]
  ! LE              [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 70

    (41) expression -> expression EQ expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 41 (expression -> expression EQ expression .)
    EQ              reduce using rule 41 (expression -> expression EQ expression .)
    NEQ             reduce using rule 41 (expression -> expression EQ expression .)
    AND             reduce using rule 41 (expression -> expression EQ expression .)
    OR              reduce using rule 41 (expression -> expression EQ expression .)
    RPAREN          reduce using rule 41 (expression -> expression EQ expression .)
    COMMA           reduce using rule 41 (expression -> expression EQ expression .)
    RBRACE          reduce using rule 41 (expression -> expression EQ expression .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41

  ! PLUS            [ reduce using rule 41 (expression -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 41 (expression -> expression EQ expression .) ]
  ! TIMES           [ reduce using rule 41 (expression -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 41 (expression -> expression EQ expression .) ]
  ! MODULO          [ reduce using rule 41 (expression -> expression EQ expression .) ]
  ! GT              [ reduce using rule 41 (expression -> expression EQ expression .) ]
  ! LT              [ reduce using rule 41 (expression -> expression EQ expression .) ]
  ! GE              [ reduce using rule 41 (expression -> expression EQ expression .) ]
  ! LE              [ reduce using rule 41 (expression -> expression EQ expression .) ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 71

    (42) expression -> expression NEQ expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 42 (expression -> expression NEQ expression .)
    EQ              reduce using rule 42 (expression -> expression NEQ expression .)
    NEQ             reduce using rule 42 (expression -> expression NEQ expression .)
    AND             reduce using rule 42 (expression -> expression NEQ expression .)
    OR              reduce using rule 42 (expression -> expression NEQ expression .)
    RPAREN          reduce using rule 42 (expression -> expression NEQ expression .)
    COMMA           reduce using rule 42 (expression -> expression NEQ expression .)
    RBRACE          reduce using rule 42 (expression -> expression NEQ expression .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41

  ! PLUS            [ reduce using rule 42 (expression -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 42 (expression -> expression NEQ expression .) ]
  ! TIMES           [ reduce using rule 42 (expression -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 42 (expression -> expression NEQ expression .) ]
  ! MODULO          [ reduce using rule 42 (expression -> expression NEQ expression .) ]
  ! GT              [ reduce using rule 42 (expression -> expression NEQ expression .) ]
  ! LT              [ reduce using rule 42 (expression -> expression NEQ expression .) ]
  ! GE              [ reduce using rule 42 (expression -> expression NEQ expression .) ]
  ! LE              [ reduce using rule 42 (expression -> expression NEQ expression .) ]
  ! EQ              [ shift and go to state 42 ]
  ! NEQ             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 72

    (43) expression -> expression AND expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 43 (expression -> expression AND expression .)
    AND             reduce using rule 43 (expression -> expression AND expression .)
    OR              reduce using rule 43 (expression -> expression AND expression .)
    RPAREN          reduce using rule 43 (expression -> expression AND expression .)
    COMMA           reduce using rule 43 (expression -> expression AND expression .)
    RBRACE          reduce using rule 43 (expression -> expression AND expression .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43

  ! PLUS            [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! MODULO          [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! GT              [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! LT              [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 73

    (44) expression -> expression OR expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       reduce using rule 44 (expression -> expression OR expression .)
    OR              reduce using rule 44 (expression -> expression OR expression .)
    RPAREN          reduce using rule 44 (expression -> expression OR expression .)
    COMMA           reduce using rule 44 (expression -> expression OR expression .)
    RBRACE          reduce using rule 44 (expression -> expression OR expression .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43
    AND             shift and go to state 44

  ! PLUS            [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! MODULO          [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! GT              [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! LT              [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 45 ]


state 74

    (12) print_statement -> PRINT LPAREN expression . RPAREN SEMICOLON
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RPAREN          shift and go to state 87
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 75

    (31) expression -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 31 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 31 (expression -> LPAREN expression RPAREN .)


state 76

    (13) if_statement -> IF LPAREN expression . RPAREN block elseif_list else_block
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RPAREN          shift and go to state 88
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 77

    (21) function_definition -> ZAP IDENTIFIER LPAREN . parameter_list RPAREN block
    (22) parameter_list -> . IDENTIFIER
    (23) parameter_list -> . parameter_list COMMA IDENTIFIER
    (24) parameter_list -> . empty
    (58) empty -> .

    IDENTIFIER      shift and go to state 80
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)

    parameter_list                 shift and go to state 89
    empty                          shift and go to state 81

state 78

    (25) return_statement -> RETURN expression SEMICOLON .

    IDENTIFIER      reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    PRINT           reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    ZAP             reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    NUMBER          reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    TRUE            reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    FALSE           reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    MINUS           reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    LAMBDA          reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    SEMICOLON       reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    PLUS            reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    TIMES           reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    DIVIDE          reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    MODULO          reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    GT              reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    LT              reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    GE              reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    LE              reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    EQ              reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    NEQ             reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    AND             reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    OR              reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    $end            reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)
    RBRACE          reduce using rule 25 (return_statement -> RETURN expression SEMICOLON .)


state 79

    (55) anonymous_function -> LAMBDA LPAREN parameter_list . RPAREN COLON LBRACE expression RBRACE
    (23) parameter_list -> parameter_list . COMMA IDENTIFIER

    RPAREN          shift and go to state 90
    COMMA           shift and go to state 91


state 80

    (22) parameter_list -> IDENTIFIER .

    RPAREN          reduce using rule 22 (parameter_list -> IDENTIFIER .)
    COMMA           reduce using rule 22 (parameter_list -> IDENTIFIER .)


state 81

    (24) parameter_list -> empty .

    RPAREN          reduce using rule 24 (parameter_list -> empty .)
    COMMA           reduce using rule 24 (parameter_list -> empty .)


state 82

    (11) assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .

    IDENTIFIER      reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    ZAP             reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    NUMBER          reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LAMBDA          reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PLUS            reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TIMES           reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DIVIDE          reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MODULO          reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    GT              reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LT              reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    GE              reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LE              reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    EQ              reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    NEQ             reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    AND             reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    OR              reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 11 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 83

    (54) lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN . parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON
    (55) anonymous_function -> LAMBDA LPAREN . parameter_list RPAREN COLON LBRACE expression RBRACE
    (22) parameter_list -> . IDENTIFIER
    (23) parameter_list -> . parameter_list COMMA IDENTIFIER
    (24) parameter_list -> . empty
    (58) empty -> .

    IDENTIFIER      shift and go to state 80
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)

    parameter_list                 shift and go to state 92
    empty                          shift and go to state 81

state 84

    (57) function_call -> IDENTIFIER LPAREN argument_list RPAREN .

    SEMICOLON       reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    MODULO          reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    GE              reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    LE              reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 57 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)


state 85

    (52) argument_list -> argument_list COMMA . expression
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    RPAREN          reduce using rule 58 (empty -> .)
    COMMA           reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 93
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 86

    (56) lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .

    SEMICOLON       reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    PLUS            reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    MINUS           reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    TIMES           reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    DIVIDE          reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    MODULO          reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    GT              reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    LT              reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    GE              reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    LE              reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    EQ              reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    NEQ             reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    AND             reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    OR              reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    RPAREN          reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    COMMA           reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)
    RBRACE          reduce using rule 56 (lambda_call -> IDENTIFIER LBRACE argument_list RBRACE .)


state 87

    (12) print_statement -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 94


state 88

    (13) if_statement -> IF LPAREN expression RPAREN . block elseif_list else_block
    (20) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 96

    block                          shift and go to state 95

state 89

    (21) function_definition -> ZAP IDENTIFIER LPAREN parameter_list . RPAREN block
    (23) parameter_list -> parameter_list . COMMA IDENTIFIER

    RPAREN          shift and go to state 97
    COMMA           shift and go to state 91


state 90

    (55) anonymous_function -> LAMBDA LPAREN parameter_list RPAREN . COLON LBRACE expression RBRACE

    COLON           shift and go to state 98


state 91

    (23) parameter_list -> parameter_list COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 99


state 92

    (54) lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list . RPAREN COLON LBRACE expression RBRACE SEMICOLON
    (55) anonymous_function -> LAMBDA LPAREN parameter_list . RPAREN COLON LBRACE expression RBRACE
    (23) parameter_list -> parameter_list . COMMA IDENTIFIER

    RPAREN          shift and go to state 100
    COMMA           shift and go to state 91


state 93

    (52) argument_list -> argument_list COMMA expression .
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RPAREN          reduce using rule 52 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 52 (argument_list -> argument_list COMMA expression .)
    RBRACE          reduce using rule 52 (argument_list -> argument_list COMMA expression .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 94

    (12) print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ZAP             reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RETURN          reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    NUMBER          reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    TRUE            reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FALSE           reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LPAREN          reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    NOT             reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MINUS           reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LAMBDA          reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PLUS            reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    TIMES           reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DIVIDE          reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MODULO          reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    GT              reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LT              reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    GE              reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LE              reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    EQ              reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    NEQ             reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    AND             reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    OR              reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    $end            reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 12 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 95

    (13) if_statement -> IF LPAREN expression RPAREN block . elseif_list else_block
    (14) elseif_list -> . elseif
    (15) elseif_list -> . elseif_list elseif
    (16) elseif_list -> . empty
    (17) elseif -> . ELSEIF LPAREN expression RPAREN block
    (58) empty -> .

  ! shift/reduce conflict for ELSEIF resolved as shift
    ELSEIF          shift and go to state 104
    ELSE            reduce using rule 58 (empty -> .)
    IDENTIFIER      reduce using rule 58 (empty -> .)
    PRINT           reduce using rule 58 (empty -> .)
    IF              reduce using rule 58 (empty -> .)
    ZAP             reduce using rule 58 (empty -> .)
    RETURN          reduce using rule 58 (empty -> .)
    NUMBER          reduce using rule 58 (empty -> .)
    TRUE            reduce using rule 58 (empty -> .)
    FALSE           reduce using rule 58 (empty -> .)
    LPAREN          reduce using rule 58 (empty -> .)
    NOT             reduce using rule 58 (empty -> .)
    MINUS           reduce using rule 58 (empty -> .)
    LAMBDA          reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    $end            reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

  ! ELSEIF          [ reduce using rule 58 (empty -> .) ]

    elseif_list                    shift and go to state 101
    elseif                         shift and go to state 102
    empty                          shift and go to state 103

state 96

    (20) block -> LBRACE . statement_list RBRACE
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . assignment_statement
    (5) statement -> . print_statement
    (6) statement -> . if_statement
    (7) statement -> . function_definition
    (8) statement -> . return_statement
    (9) statement -> . expression_statement
    (10) statement -> . lambda_expression
    (11) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (12) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (13) if_statement -> . IF LPAREN expression RPAREN block elseif_list else_block
    (21) function_definition -> . ZAP IDENTIFIER LPAREN parameter_list RPAREN block
    (25) return_statement -> . RETURN expression SEMICOLON
    (26) expression_statement -> . expression SEMICOLON
    (54) lambda_expression -> . IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      shift and go to state 11
    PRINT           shift and go to state 13
    IF              shift and go to state 15
    ZAP             shift and go to state 16
    RETURN          shift and go to state 17
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    SEMICOLON       reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    statement_list                 shift and go to state 105
    statement                      shift and go to state 3
    assignment_statement           shift and go to state 4
    print_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    function_definition            shift and go to state 7
    return_statement               shift and go to state 8
    expression_statement           shift and go to state 9
    lambda_expression              shift and go to state 10
    expression                     shift and go to state 12
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 97

    (21) function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN . block
    (20) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 96

    block                          shift and go to state 106

state 98

    (55) anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON . LBRACE expression RBRACE

    LBRACE          shift and go to state 107


state 99

    (23) parameter_list -> parameter_list COMMA IDENTIFIER .

    RPAREN          reduce using rule 23 (parameter_list -> parameter_list COMMA IDENTIFIER .)
    COMMA           reduce using rule 23 (parameter_list -> parameter_list COMMA IDENTIFIER .)


state 100

    (54) lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN . COLON LBRACE expression RBRACE SEMICOLON
    (55) anonymous_function -> LAMBDA LPAREN parameter_list RPAREN . COLON LBRACE expression RBRACE

    COLON           shift and go to state 108


state 101

    (13) if_statement -> IF LPAREN expression RPAREN block elseif_list . else_block
    (15) elseif_list -> elseif_list . elseif
    (18) else_block -> . ELSE block
    (19) else_block -> . empty
    (17) elseif -> . ELSEIF LPAREN expression RPAREN block
    (58) empty -> .

    ELSE            shift and go to state 111
    ELSEIF          shift and go to state 104
    IDENTIFIER      reduce using rule 58 (empty -> .)
    PRINT           reduce using rule 58 (empty -> .)
    IF              reduce using rule 58 (empty -> .)
    ZAP             reduce using rule 58 (empty -> .)
    RETURN          reduce using rule 58 (empty -> .)
    NUMBER          reduce using rule 58 (empty -> .)
    TRUE            reduce using rule 58 (empty -> .)
    FALSE           reduce using rule 58 (empty -> .)
    LPAREN          reduce using rule 58 (empty -> .)
    NOT             reduce using rule 58 (empty -> .)
    MINUS           reduce using rule 58 (empty -> .)
    LAMBDA          reduce using rule 58 (empty -> .)
    SEMICOLON       reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)
    $end            reduce using rule 58 (empty -> .)
    RBRACE          reduce using rule 58 (empty -> .)

    else_block                     shift and go to state 109
    elseif                         shift and go to state 110
    empty                          shift and go to state 112

state 102

    (14) elseif_list -> elseif .

    ELSE            reduce using rule 14 (elseif_list -> elseif .)
    ELSEIF          reduce using rule 14 (elseif_list -> elseif .)
    IDENTIFIER      reduce using rule 14 (elseif_list -> elseif .)
    PRINT           reduce using rule 14 (elseif_list -> elseif .)
    IF              reduce using rule 14 (elseif_list -> elseif .)
    ZAP             reduce using rule 14 (elseif_list -> elseif .)
    RETURN          reduce using rule 14 (elseif_list -> elseif .)
    NUMBER          reduce using rule 14 (elseif_list -> elseif .)
    TRUE            reduce using rule 14 (elseif_list -> elseif .)
    FALSE           reduce using rule 14 (elseif_list -> elseif .)
    LPAREN          reduce using rule 14 (elseif_list -> elseif .)
    NOT             reduce using rule 14 (elseif_list -> elseif .)
    MINUS           reduce using rule 14 (elseif_list -> elseif .)
    LAMBDA          reduce using rule 14 (elseif_list -> elseif .)
    SEMICOLON       reduce using rule 14 (elseif_list -> elseif .)
    PLUS            reduce using rule 14 (elseif_list -> elseif .)
    TIMES           reduce using rule 14 (elseif_list -> elseif .)
    DIVIDE          reduce using rule 14 (elseif_list -> elseif .)
    MODULO          reduce using rule 14 (elseif_list -> elseif .)
    GT              reduce using rule 14 (elseif_list -> elseif .)
    LT              reduce using rule 14 (elseif_list -> elseif .)
    GE              reduce using rule 14 (elseif_list -> elseif .)
    LE              reduce using rule 14 (elseif_list -> elseif .)
    EQ              reduce using rule 14 (elseif_list -> elseif .)
    NEQ             reduce using rule 14 (elseif_list -> elseif .)
    AND             reduce using rule 14 (elseif_list -> elseif .)
    OR              reduce using rule 14 (elseif_list -> elseif .)
    $end            reduce using rule 14 (elseif_list -> elseif .)
    RBRACE          reduce using rule 14 (elseif_list -> elseif .)


state 103

    (16) elseif_list -> empty .

    ELSE            reduce using rule 16 (elseif_list -> empty .)
    ELSEIF          reduce using rule 16 (elseif_list -> empty .)
    IDENTIFIER      reduce using rule 16 (elseif_list -> empty .)
    PRINT           reduce using rule 16 (elseif_list -> empty .)
    IF              reduce using rule 16 (elseif_list -> empty .)
    ZAP             reduce using rule 16 (elseif_list -> empty .)
    RETURN          reduce using rule 16 (elseif_list -> empty .)
    NUMBER          reduce using rule 16 (elseif_list -> empty .)
    TRUE            reduce using rule 16 (elseif_list -> empty .)
    FALSE           reduce using rule 16 (elseif_list -> empty .)
    LPAREN          reduce using rule 16 (elseif_list -> empty .)
    NOT             reduce using rule 16 (elseif_list -> empty .)
    MINUS           reduce using rule 16 (elseif_list -> empty .)
    LAMBDA          reduce using rule 16 (elseif_list -> empty .)
    SEMICOLON       reduce using rule 16 (elseif_list -> empty .)
    PLUS            reduce using rule 16 (elseif_list -> empty .)
    TIMES           reduce using rule 16 (elseif_list -> empty .)
    DIVIDE          reduce using rule 16 (elseif_list -> empty .)
    MODULO          reduce using rule 16 (elseif_list -> empty .)
    GT              reduce using rule 16 (elseif_list -> empty .)
    LT              reduce using rule 16 (elseif_list -> empty .)
    GE              reduce using rule 16 (elseif_list -> empty .)
    LE              reduce using rule 16 (elseif_list -> empty .)
    EQ              reduce using rule 16 (elseif_list -> empty .)
    NEQ             reduce using rule 16 (elseif_list -> empty .)
    AND             reduce using rule 16 (elseif_list -> empty .)
    OR              reduce using rule 16 (elseif_list -> empty .)
    $end            reduce using rule 16 (elseif_list -> empty .)
    RBRACE          reduce using rule 16 (elseif_list -> empty .)


state 104

    (17) elseif -> ELSEIF . LPAREN expression RPAREN block

    LPAREN          shift and go to state 113


state 105

    (20) block -> LBRACE statement_list . RBRACE
    (3) statement_list -> statement_list . statement
    (4) statement -> . assignment_statement
    (5) statement -> . print_statement
    (6) statement -> . if_statement
    (7) statement -> . function_definition
    (8) statement -> . return_statement
    (9) statement -> . expression_statement
    (10) statement -> . lambda_expression
    (11) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (12) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (13) if_statement -> . IF LPAREN expression RPAREN block elseif_list else_block
    (21) function_definition -> . ZAP IDENTIFIER LPAREN parameter_list RPAREN block
    (25) return_statement -> . RETURN expression SEMICOLON
    (26) expression_statement -> . expression SEMICOLON
    (54) lambda_expression -> . IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    RBRACE          shift and go to state 114
    IDENTIFIER      shift and go to state 11
    PRINT           shift and go to state 13
    IF              shift and go to state 15
    ZAP             shift and go to state 16
    RETURN          shift and go to state 17
    NUMBER          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    SEMICOLON       reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    statement                      shift and go to state 28
    assignment_statement           shift and go to state 4
    print_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    function_definition            shift and go to state 7
    return_statement               shift and go to state 8
    expression_statement           shift and go to state 9
    lambda_expression              shift and go to state 10
    expression                     shift and go to state 12
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 106

    (21) function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .

    IDENTIFIER      reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    PRINT           reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    IF              reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    ZAP             reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    RETURN          reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    NUMBER          reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    TRUE            reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    FALSE           reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    LPAREN          reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    NOT             reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    MINUS           reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    LAMBDA          reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    SEMICOLON       reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    PLUS            reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    TIMES           reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    DIVIDE          reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    MODULO          reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    GT              reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    LT              reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    GE              reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    LE              reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    EQ              reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    NEQ             reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    AND             reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    OR              reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    $end            reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)
    RBRACE          reduce using rule 21 (function_definition -> ZAP IDENTIFIER LPAREN parameter_list RPAREN block .)


state 107

    (55) anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE . expression RBRACE
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    RBRACE          reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 115
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 108

    (54) lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON . LBRACE expression RBRACE SEMICOLON
    (55) anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON . LBRACE expression RBRACE

    LBRACE          shift and go to state 116


state 109

    (13) if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .

    IDENTIFIER      reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    PRINT           reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    IF              reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    ZAP             reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    RETURN          reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    NUMBER          reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    TRUE            reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    FALSE           reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    LPAREN          reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    NOT             reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    MINUS           reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    LAMBDA          reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    SEMICOLON       reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    PLUS            reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    TIMES           reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    DIVIDE          reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    MODULO          reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    GT              reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    LT              reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    GE              reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    LE              reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    EQ              reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    NEQ             reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    AND             reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    OR              reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    $end            reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)
    RBRACE          reduce using rule 13 (if_statement -> IF LPAREN expression RPAREN block elseif_list else_block .)


state 110

    (15) elseif_list -> elseif_list elseif .

    ELSE            reduce using rule 15 (elseif_list -> elseif_list elseif .)
    ELSEIF          reduce using rule 15 (elseif_list -> elseif_list elseif .)
    IDENTIFIER      reduce using rule 15 (elseif_list -> elseif_list elseif .)
    PRINT           reduce using rule 15 (elseif_list -> elseif_list elseif .)
    IF              reduce using rule 15 (elseif_list -> elseif_list elseif .)
    ZAP             reduce using rule 15 (elseif_list -> elseif_list elseif .)
    RETURN          reduce using rule 15 (elseif_list -> elseif_list elseif .)
    NUMBER          reduce using rule 15 (elseif_list -> elseif_list elseif .)
    TRUE            reduce using rule 15 (elseif_list -> elseif_list elseif .)
    FALSE           reduce using rule 15 (elseif_list -> elseif_list elseif .)
    LPAREN          reduce using rule 15 (elseif_list -> elseif_list elseif .)
    NOT             reduce using rule 15 (elseif_list -> elseif_list elseif .)
    MINUS           reduce using rule 15 (elseif_list -> elseif_list elseif .)
    LAMBDA          reduce using rule 15 (elseif_list -> elseif_list elseif .)
    SEMICOLON       reduce using rule 15 (elseif_list -> elseif_list elseif .)
    PLUS            reduce using rule 15 (elseif_list -> elseif_list elseif .)
    TIMES           reduce using rule 15 (elseif_list -> elseif_list elseif .)
    DIVIDE          reduce using rule 15 (elseif_list -> elseif_list elseif .)
    MODULO          reduce using rule 15 (elseif_list -> elseif_list elseif .)
    GT              reduce using rule 15 (elseif_list -> elseif_list elseif .)
    LT              reduce using rule 15 (elseif_list -> elseif_list elseif .)
    GE              reduce using rule 15 (elseif_list -> elseif_list elseif .)
    LE              reduce using rule 15 (elseif_list -> elseif_list elseif .)
    EQ              reduce using rule 15 (elseif_list -> elseif_list elseif .)
    NEQ             reduce using rule 15 (elseif_list -> elseif_list elseif .)
    AND             reduce using rule 15 (elseif_list -> elseif_list elseif .)
    OR              reduce using rule 15 (elseif_list -> elseif_list elseif .)
    $end            reduce using rule 15 (elseif_list -> elseif_list elseif .)
    RBRACE          reduce using rule 15 (elseif_list -> elseif_list elseif .)


state 111

    (18) else_block -> ELSE . block
    (20) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 96

    block                          shift and go to state 117

state 112

    (19) else_block -> empty .

    IDENTIFIER      reduce using rule 19 (else_block -> empty .)
    PRINT           reduce using rule 19 (else_block -> empty .)
    IF              reduce using rule 19 (else_block -> empty .)
    ZAP             reduce using rule 19 (else_block -> empty .)
    RETURN          reduce using rule 19 (else_block -> empty .)
    NUMBER          reduce using rule 19 (else_block -> empty .)
    TRUE            reduce using rule 19 (else_block -> empty .)
    FALSE           reduce using rule 19 (else_block -> empty .)
    LPAREN          reduce using rule 19 (else_block -> empty .)
    NOT             reduce using rule 19 (else_block -> empty .)
    MINUS           reduce using rule 19 (else_block -> empty .)
    LAMBDA          reduce using rule 19 (else_block -> empty .)
    SEMICOLON       reduce using rule 19 (else_block -> empty .)
    PLUS            reduce using rule 19 (else_block -> empty .)
    TIMES           reduce using rule 19 (else_block -> empty .)
    DIVIDE          reduce using rule 19 (else_block -> empty .)
    MODULO          reduce using rule 19 (else_block -> empty .)
    GT              reduce using rule 19 (else_block -> empty .)
    LT              reduce using rule 19 (else_block -> empty .)
    GE              reduce using rule 19 (else_block -> empty .)
    LE              reduce using rule 19 (else_block -> empty .)
    EQ              reduce using rule 19 (else_block -> empty .)
    NEQ             reduce using rule 19 (else_block -> empty .)
    AND             reduce using rule 19 (else_block -> empty .)
    OR              reduce using rule 19 (else_block -> empty .)
    $end            reduce using rule 19 (else_block -> empty .)
    RBRACE          reduce using rule 19 (else_block -> empty .)


state 113

    (17) elseif -> ELSEIF LPAREN . expression RPAREN block
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    RPAREN          reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 118
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 114

    (20) block -> LBRACE statement_list RBRACE .

    ELSEIF          reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    PRINT           reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    ZAP             reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    NUMBER          reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    NOT             reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    LAMBDA          reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    SEMICOLON       reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    PLUS            reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    TIMES           reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    DIVIDE          reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    MODULO          reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    GT              reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    LT              reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    GE              reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    LE              reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    EQ              reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    NEQ             reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    AND             reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    OR              reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 20 (block -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 20 (block -> LBRACE statement_list RBRACE .)


state 115

    (55) anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression . RBRACE
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RBRACE          shift and go to state 119
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 116

    (54) lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE . expression RBRACE SEMICOLON
    (55) anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE . expression RBRACE
    (27) expression -> . NUMBER
    (28) expression -> . IDENTIFIER
    (29) expression -> . TRUE
    (30) expression -> . FALSE
    (31) expression -> . LPAREN expression RPAREN
    (32) expression -> . expression PLUS expression
    (33) expression -> . expression MINUS expression
    (34) expression -> . expression TIMES expression
    (35) expression -> . expression DIVIDE expression
    (36) expression -> . expression MODULO expression
    (37) expression -> . expression GT expression
    (38) expression -> . expression LT expression
    (39) expression -> . expression GE expression
    (40) expression -> . expression LE expression
    (41) expression -> . expression EQ expression
    (42) expression -> . expression NEQ expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . MINUS expression
    (47) expression -> . function_call
    (48) expression -> . anonymous_function
    (49) expression -> . lambda_call
    (50) expression -> . empty
    (57) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (55) anonymous_function -> . LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE
    (56) lambda_call -> . IDENTIFIER LBRACE argument_list RBRACE
    (58) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 48
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    LPAREN          shift and go to state 14
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    LAMBDA          shift and go to state 18
    RBRACE          reduce using rule 58 (empty -> .)
    PLUS            reduce using rule 58 (empty -> .)
    TIMES           reduce using rule 58 (empty -> .)
    DIVIDE          reduce using rule 58 (empty -> .)
    MODULO          reduce using rule 58 (empty -> .)
    GT              reduce using rule 58 (empty -> .)
    LT              reduce using rule 58 (empty -> .)
    GE              reduce using rule 58 (empty -> .)
    LE              reduce using rule 58 (empty -> .)
    EQ              reduce using rule 58 (empty -> .)
    NEQ             reduce using rule 58 (empty -> .)
    AND             reduce using rule 58 (empty -> .)
    OR              reduce using rule 58 (empty -> .)

  ! MINUS           [ reduce using rule 58 (empty -> .) ]

    expression                     shift and go to state 120
    function_call                  shift and go to state 24
    anonymous_function             shift and go to state 25
    lambda_call                    shift and go to state 26
    empty                          shift and go to state 27

state 117

    (18) else_block -> ELSE block .

    IDENTIFIER      reduce using rule 18 (else_block -> ELSE block .)
    PRINT           reduce using rule 18 (else_block -> ELSE block .)
    IF              reduce using rule 18 (else_block -> ELSE block .)
    ZAP             reduce using rule 18 (else_block -> ELSE block .)
    RETURN          reduce using rule 18 (else_block -> ELSE block .)
    NUMBER          reduce using rule 18 (else_block -> ELSE block .)
    TRUE            reduce using rule 18 (else_block -> ELSE block .)
    FALSE           reduce using rule 18 (else_block -> ELSE block .)
    LPAREN          reduce using rule 18 (else_block -> ELSE block .)
    NOT             reduce using rule 18 (else_block -> ELSE block .)
    MINUS           reduce using rule 18 (else_block -> ELSE block .)
    LAMBDA          reduce using rule 18 (else_block -> ELSE block .)
    SEMICOLON       reduce using rule 18 (else_block -> ELSE block .)
    PLUS            reduce using rule 18 (else_block -> ELSE block .)
    TIMES           reduce using rule 18 (else_block -> ELSE block .)
    DIVIDE          reduce using rule 18 (else_block -> ELSE block .)
    MODULO          reduce using rule 18 (else_block -> ELSE block .)
    GT              reduce using rule 18 (else_block -> ELSE block .)
    LT              reduce using rule 18 (else_block -> ELSE block .)
    GE              reduce using rule 18 (else_block -> ELSE block .)
    LE              reduce using rule 18 (else_block -> ELSE block .)
    EQ              reduce using rule 18 (else_block -> ELSE block .)
    NEQ             reduce using rule 18 (else_block -> ELSE block .)
    AND             reduce using rule 18 (else_block -> ELSE block .)
    OR              reduce using rule 18 (else_block -> ELSE block .)
    $end            reduce using rule 18 (else_block -> ELSE block .)
    RBRACE          reduce using rule 18 (else_block -> ELSE block .)


state 118

    (17) elseif -> ELSEIF LPAREN expression . RPAREN block
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RPAREN          shift and go to state 121
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 119

    (55) anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .

    SEMICOLON       reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    PLUS            reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    MINUS           reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    TIMES           reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    DIVIDE          reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    MODULO          reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    GT              reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    LT              reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    GE              reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    LE              reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    EQ              reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    NEQ             reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    AND             reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    OR              reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    RPAREN          reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    COMMA           reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    RBRACE          reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)


state 120

    (54) lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression . RBRACE SEMICOLON
    (55) anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression . RBRACE
    (32) expression -> expression . PLUS expression
    (33) expression -> expression . MINUS expression
    (34) expression -> expression . TIMES expression
    (35) expression -> expression . DIVIDE expression
    (36) expression -> expression . MODULO expression
    (37) expression -> expression . GT expression
    (38) expression -> expression . LT expression
    (39) expression -> expression . GE expression
    (40) expression -> expression . LE expression
    (41) expression -> expression . EQ expression
    (42) expression -> expression . NEQ expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RBRACE          shift and go to state 122
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULO          shift and go to state 37
    GT              shift and go to state 38
    LT              shift and go to state 39
    GE              shift and go to state 40
    LE              shift and go to state 41
    EQ              shift and go to state 42
    NEQ             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 121

    (17) elseif -> ELSEIF LPAREN expression RPAREN . block
    (20) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 96

    block                          shift and go to state 123

state 122

    (54) lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE . SEMICOLON
    (55) anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 124
    PLUS            reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    MINUS           reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    TIMES           reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    DIVIDE          reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    MODULO          reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    GT              reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    LT              reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    GE              reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    LE              reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    EQ              reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    NEQ             reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    AND             reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)
    OR              reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .)

  ! SEMICOLON       [ reduce using rule 55 (anonymous_function -> LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE .) ]


state 123

    (17) elseif -> ELSEIF LPAREN expression RPAREN block .

    ELSE            reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    ELSEIF          reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    IDENTIFIER      reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    PRINT           reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    IF              reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    ZAP             reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    RETURN          reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    NUMBER          reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    TRUE            reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    FALSE           reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    LPAREN          reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    NOT             reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    MINUS           reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    LAMBDA          reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    SEMICOLON       reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    PLUS            reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    TIMES           reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    DIVIDE          reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    MODULO          reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    GT              reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    LT              reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    GE              reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    LE              reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    EQ              reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    NEQ             reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    AND             reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    OR              reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    $end            reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)
    RBRACE          reduce using rule 17 (elseif -> ELSEIF LPAREN expression RPAREN block .)


state 124

    (54) lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .

    IDENTIFIER      reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    PRINT           reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    IF              reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    ZAP             reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    RETURN          reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    NUMBER          reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    TRUE            reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    FALSE           reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    LPAREN          reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    NOT             reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    MINUS           reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    LAMBDA          reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    SEMICOLON       reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    PLUS            reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    TIMES           reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    DIVIDE          reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    MODULO          reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    GT              reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    LT              reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    GE              reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    LE              reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    EQ              reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    NEQ             reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    AND             reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    OR              reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    $end            reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)
    RBRACE          reduce using rule 54 (lambda_expression -> IDENTIFIER ASSIGN LAMBDA LPAREN parameter_list RPAREN COLON LBRACE expression RBRACE SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 2 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 14 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 17 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 22 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 23 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 29 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 30 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 31 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 33 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 34 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 35 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 36 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 37 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 38 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 39 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 40 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 41 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 42 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 43 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 44 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 45 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 46 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 49 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 85 resolved as shift
WARNING: shift/reduce conflict for ELSEIF in state 95 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 96 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 122 resolved as shift
WARNING: reduce/reduce conflict in state 59 resolved using rule (expression -> empty)
WARNING: rejected rule (argument_list -> empty) in state 59
WARNING: Rule (argument_list -> empty) is never reduced
